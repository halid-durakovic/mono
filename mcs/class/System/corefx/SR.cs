//
// This file was generated by resx2sr tool
//

partial class SR
{
	public const string net_invalidversion = "This protocol version is not supported.";
	public const string net_noseek = "This stream does not support seek operations.";
	public const string net_invasync = "Cannot block a call on this socket while an earlier asynchronous call is in progress.";
	public const string net_io_timeout_use_gt_zero = "Timeout can be only be set to 'System.Threading.Timeout.Infinite' or a value > 0.";
	public const string net_notconnected = "The operation is not allowed on non-connected sockets.";
	public const string net_notstream = "The operation is not allowed on non-stream oriented sockets.";
	public const string net_stopped = "Not listening. You must call the Start() method before calling this method.";
	public const string net_udpconnected = "Cannot send packets to an arbitrary host while connected.";
	public const string net_readonlystream = "The stream does not support writing.";
	public const string net_writeonlystream = "The stream does not support reading.";
	public const string net_InvalidSocketHandle = "The socket handle is not valid.";
	public const string net_InvalidAddressFamily = "The AddressFamily {0} is not valid for the {1} end point, use {2} instead.";
	public const string net_InvalidEndPointAddressFamily = "The supplied EndPoint of AddressFamily {0} is not valid for this Socket, use {1} instead.";
	public const string net_InvalidSocketAddressSize = "The supplied {0} is an invalid size for the {1} end point.";
	public const string net_invalidAddressList = "None of the discovered or specified addresses match the socket address family.";
	public const string net_completed_result = "This operation cannot be performed on a completed asynchronous result object.";
	public const string net_protocol_invalid_family = "'{0}' Client can only accept InterNetwork or InterNetworkV6 addresses.";
	public const string net_protocol_invalid_multicast_family = "Multicast family is not the same as the family of the '{0}' Client.";
	public const string net_sockets_zerolist = "The parameter {0} must contain one or more elements.";
	public const string net_sockets_blocking = "The operation is not allowed on a non-blocking Socket.";
	public const string net_sockets_useblocking = "Use the Blocking property to change the status of the Socket.";
	public const string net_sockets_select = "The operation is not allowed on objects of type {0}. Use only objects of type {1}.";
	public const string net_sockets_toolarge_select = "The {0} list contains too many items; a maximum of {1} is allowed.";
	public const string net_sockets_empty_select = "All lists are either null or empty.";
	public const string net_sockets_mustbind = "You must call the Bind method before performing this operation.";
	public const string net_sockets_mustlisten = "You must call the Listen method before performing this operation.";
	public const string net_sockets_mustnotlisten = "You may not perform this operation after calling the Listen method.";
	public const string net_sockets_mustnotbebound = "The socket must not be bound or connected.";
	public const string net_sockets_namedmustnotbebound = "{0}: The socket must not be bound or connected.";
	public const string net_sockets_invalid_ipaddress_length = "The number of specified IP addresses has to be greater than 0.";
	public const string net_sockets_invalid_optionValue = "The specified value is not a valid '{0}'.";
	public const string net_sockets_invalid_optionValue_all = "The specified value is not valid.";
	public const string net_sockets_invalid_dnsendpoint = "The parameter {0} must not be of type DnsEndPoint.";
	public const string net_sockets_disconnectedConnect = "Once the socket has been disconnected, you can only reconnect again asynchronously, and only to a different EndPoint.  BeginConnect must be called on a thread that won't exit until the operation has been completed.";
	public const string net_sockets_disconnectedAccept = "Once the socket has been disconnected, you can only accept again asynchronously.  BeginAccept must be called on a thread that won't exit until the operation has been completed.";
	public const string net_tcplistener_mustbestopped = "The TcpListener must not be listening before performing this operation.";
	public const string net_socketopinprogress = "An asynchronous socket operation is already in progress using this SocketAsyncEventArgs instance.";
	public const string net_buffercounttoosmall = "The Buffer space specified by the Count property is insufficient for the AcceptAsync method.";
	public const string net_multibuffernotsupported = "Multiple buffers cannot be used with this method.";
	public const string net_ambiguousbuffers = "Buffer and BufferList properties cannot both be non-null.";
	public const string net_io_writefailure = "Unable to write data to the transport connection: {0}.";
	public const string net_io_readfailure = "Unable to read data from the transport connection: {0}.";
	public const string net_io_connectionclosed = "The connection was closed";
	public const string net_io_invalidasyncresult = "The IAsyncResult object was not returned from the corresponding asynchronous method on this class.";
	public const string net_io_invalidendcall = "{0} can only be called once for each asynchronous operation.";
	public const string net_value_cannot_be_negative = "The specified value cannot be negative.";
	public const string net_log_exception = "Exception in {0}::{1} - {2}.";
	public const string net_log_socket_connected = "Created connection from {0} to {1}.";
	public const string event_Accepted = "Accepted connection from {0} to {1}.";
	public const string event_NotLoggedFile = "Not logging data from file: {0}.";
	public const string event_ConnectedAsyncDns = "Connecting to a DnsEndPoint.";
	public const string ArgumentOutOfRange_Bounds_Lower_Upper = "Argument must be between {0} and {1}.";
	public const string net_sockets_connect_multiaddress_notsupported = "This platform does not support connecting sockets to DNS endpoints via the instance Connect and ConnectAsync methods, due to the potential for a host name to map to multiple IP addresses and sockets becoming invalid for use after a failed connect attempt. Use the static ConnectAsync method, or provide to the instance methods the specific IPAddress desired.";
	public const string net_sockets_connect_multiconnect_notsupported = "Sockets on this platform are invalid for use after a failed connection attempt.";
	public const string net_sockets_dualmode_receivefrom_notsupported = "This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.";
	public const string net_sockets_accept_receive_notsupported = "This platform does not support receiving data with Socket.AcceptAsync.  Instead, make a separate call to Socket.ReceiveAsync.";
	public const string net_sockets_duplicateandclose_notsupported = "This platform does not support Socket.DuplicateAndClose.  Instead, create a new socket.";
	public const string net_sockets_disconnect_notsupported = "This platform does not support disconnecting a Socket.  Instead, close the Socket and create a new one.";
	public const string net_sockets_transmitfileoptions_notsupported = "This platform does not support TransmitFileOptions other than TransmitFileOptions.UseDefaultWorkerThread.";
	public const string NotSupported_UnreadableStream = "Stream does not support reading.";
	public const string NotSupported_UnwritableStream = "Stream does not support writing.";
	public const string ObjectDisposed_StreamClosed = "Can not access a closed Stream.";
	public const string ArgumentOutOfRange_NeedPosNum = "Positive number required.";
}
